{
	"Add Packages": {
		"prefix": "Gen4-NugetPackages",
		"body": [
			"// API",
			"dotnet add package AspNetCoreRateLimit",
			"dotnet add package AutoMapper.Extensions.Microsoft.DependencyInjection",
			"dotnet add package Microsoft.AspNetCore.Authentication.JwtBearer",
			"dotnet add package Microsoft.AspNetCore.Mvc.Versioning",
			"dotnet add package Microsoft.AspNetCore.OpenApi",
			"dotnet add package Microsoft.EntityFrameworkCore.Design",
			"dotnet add package System.IdentityModel.Tokens.Jwt",
			"dotnet add package Serilog.AspNetCore",
			"dotnet add package Microsoft.Extensions.DependencyInjection",
			"dotnet add package Microsoft.EntityFrameworkCore",
			"// DOMAIN",
			"dotnet add package FluentValidation.AspNetCore",
			"dotnet add package itext7.pdfhtml",
			"dotnet add package Microsoft.EntityFrameworkCore",
			"// PERSISTENCE",
			"dotnet add package Microsoft.EntityFrameworkCore",
			"dotnet add package Pomelo.EntityFrameworkCore.MySql"
		],
		"description": "Agregar múltiples paquetes NuGet al proyecto"
	},
	"RepoGenerico": {
		"prefix": "Gen4-GenericRepository-InRepositories",
		"body": [
			"using System.Linq.Expressions; // 2611",
			"using Domain.Entities;",
			"using Domain.Interfaces;",
			"using Persistence.Data;",
			"using Microsoft.EntityFrameworkCore;",
			"",
			"namespace Application.Repositories;",
			"",
			"public class GenericRepository<T> : IGenericRepository<T> where T : BaseEntity",
			"{",
			"\tprivate readonly ${Context} _context;",
			"",
			"\tpublic GenericRepository(${Context} context)",
			"\t{",
			"\t\t_context = context;",
			"\t}",
			"",
			"\tpublic virtual void Add(T entity)",
			"\t{",
			"\t\t_context.Set<T>().Add(entity);",
			"\t}",
			"",
			"\tpublic virtual void AddRange(IEnumerable<T> entities)",
			"\t{",
			"\t\t_context.Set<T>().AddRange(entities);",
			"\t}",
			"",
			"\tpublic virtual IEnumerable<T> Find(Expression<Func<T, bool>> expression)",
			"\t{",
			"\t\treturn _context.Set<T>().Where(expression);",
			"\t}",
			"",
			"\tpublic virtual async Task<IEnumerable<T>> GetAllAsync()",
			"\t{",
			"\t\treturn await _context.Set<T>().ToListAsync();",
			"\t\t// return (IEnumerable<T>) await _context.${Entities}.FromSqlRaw(\"SELECT * FROM ${entity}\").ToListAsync();",
			"\t}",
			"",
			"\tpublic virtual async Task<T> GetByIdAsync(int id)",
			"\t{",
			"\t\treturn await _context.Set<T>().FindAsync(id);",
			"\t}",
			"",
			"\tpublic virtual void Remove(T entity)",
			"\t{",
			"\t\t_context.Set<T>().Remove(entity);",
			"\t}",
			"",
			"\tpublic virtual void RemoveRange(IEnumerable<T> entities)",
			"\t{",
			"\t\t_context.Set<T>().RemoveRange(entities);",
			"\t}",
			"",
			"\tpublic virtual void Update(T entity)",
			"\t{",
			"\t\t_context.Set<T>().Update(entity);",
			"\t}",
			"\tpublic virtual async Task<(int totalRegistros, IEnumerable<T> registros)> GetAllAsync(",
            "\t\tint pageIndex,",
            "\t\tint pageSize,",
            "\t\tstring _search",
            "\t)",
            "\t{",
            "\t\tvar totalRegistros = await _context.Set<T>().CountAsync();",
            "\t\tvar registros = await _context",
            "\t\t\t.Set<T>()",
            "\t\t\t.Skip((pageIndex - 1) * pageSize)",
            "\t\t\t.Take(pageSize)",
            "\t\t\t.ToListAsync();",
            "\t\treturn (totalRegistros, registros);",
            "\t}",
			"}"
		],
		"description": "Snippet for GenericRepositoryA class"
	},
	"IGenericRepository": {
		"prefix": "Gen4-IGenericRepository-InInterfaces",
		"body": [
			"using System.Linq.Expressions; // 2611",
			"using Domain.Entities;",
			"",
			"namespace Domain.Interfaces;",
			"",
			"public interface IGenericRepository<T> where T : BaseEntity",
			"{",
			"\tTask<T> GetByIdAsync(int Id);",
			"\tTask<IEnumerable<T>> GetAllAsync();",
			"\tIEnumerable<T> Find(Expression<Func<T, bool>> expression);",
			"\t// Task<(int totalRegistros, IEnumerable<T> registros)> GetAllAsync(int pageIndex, int pageSize, string search);",
			"\tvoid Add(T entity);",
			"\tvoid AddRange(IEnumerable<T> entities);",
			"\tvoid Remove(T entity);",
			"\tvoid RemoveRange(IEnumerable<T> entities);",
			"\tvoid Update(T entity);",
			"}"
		]
	},
	"EntityConfiguration": {
		"prefix": "Gen4-Entity-InConfiguration",
		"body": [
			"using Domain.Entities; // 2611",
			"using Microsoft.EntityFrameworkCore;",
			"using Microsoft.EntityFrameworkCore.Metadata.Builders;",
			"",
			"namespace Persistence.Data.Configuration;",
			"",
			"public class ${Entity}Configuration : IEntityTypeConfiguration<${Entity}>",
			"{",
			"\tpublic void Configure(EntityTypeBuilder<${Entity}> builder)",
			"\t{",
			"\t\t//Here you can configure the properties using the object 'Builder'.",
			"\t}",
			"}"
		]
	},
	"ToTable": {
		"prefix": "Gen4-ToTable-InConfiguration",
		"body": [
			"builder.ToTable(\"${TableName}\"); // 2611"
		],
		"description": "Snippet to generate ToTable Field"
	},
	"PrimaryKey": {
		"prefix": "Gen4-PrimaryKey-AutoIncrement-InConfiguration",
		"body": [
			"builder.HasKey(x => x.${PrimaryKey}); // 2611",
			"builder.Property(x => x.${PrimaryKey});"
		],
		"description": "Snippet to generate a Primary Key Field"
	},
	"OneToMany": {
		"prefix": "Gen4-ForeignKey-OneToMany-InConfiguration",
		"body": [
			"builder.HasOne(x => x.${ComesFrom}).WithMany(x => x.${ComesTo}).HasForeignKey(x => x.${ForeignKey}); // 2611"
		],
		"description": "Snippet to generate a OneToMany Field"
	},
	"OneToOne": {
		"prefix": "Gen4-ForeignKey-OneToOne-InConfiguration",
		"body": [
			"builder.HasOne(x => x.${ComesFrom}).WithOne(x => x.${ComesTo}).HasForeignKey(x => x.${ForeignKey}); // 2611"
		]
	},
	"Varchar": {
		"prefix": "Gen4-Varchar-InConfiguration",
		"body": [
			"builder.Property(x => x.${Varchar}).HasMaxLength(${Length}); // 2611"
		],
		"description": "Snippet to generate a Varchar Field"
	},
	"RequiredVarchar": {
		"prefix": "Gen4-RequiredVarchar-InConfiguration",
		"body": [
			"builder.Property(x => x.${Varchar}).IsRequired().HasMaxLength(${Length}); // 2611"
		],
		"description": "Snippet to generate a Required Varchar Field"
	},
	"Integer": {
		"prefix": "Gen4-Int-InConfiguration",
		"body": [
			"builder.Property(x => x.${Integer}).HasColumnType(\"int\"); // 2611"
		],
		"description": "Snippet to generate an Integer Field"
	},
	"Date": {
		"prefix": "Gen4-Date-InConfiguration",
		"body": [
			"builder.Property(x => x.${Date}).HasColumnType(\"date\"); // 2611"
		],
		"description": "Snippet to generate a Date Field"
	},
	"Time": {
		"prefix": "Gen4-Time-InConfiguration",
		"body": [
			"builder.Property(x => x.${Time}).HasColumnType(\"time\"); // 2611"
		],
		"description": "Snippet to generate a Time Field"
	},
	"Double": {
		"prefix": "Gen4-Double-InConfiguration",
		"body": [
			"builder.Property(x => x.${Double}).HasColumnType(\"double\"); // 2611"
		],
		"description": "Snippet to generate a Double Field"
	},
	"PKNoAutoincrement": {
		"prefix": "Gen4-PrimaryKey-NoAutoincrement-InConfiguration",
		"body": [
			"builder.HasKey(x => x.${PrimaryKey}); // 2611",
			"builder.Property(x => x.${PrimaryKey}).ValueGeneratedNever();"
		],
		"description": "Snippet to generate a Primary Key With No Autoincrement Field"
	},
	"PKStringAnnotationDB": {
		"prefix": "Gen4-PrimaryKey-AnnotationDataBase-InConfiguration",
		"body": [
			"builder.Property(x => x.${PrimaryKey}).HasAnnotation(\"MySql:ValueGenerationStrategy\", MySqlValueGenerationStrategy.IdentityColumn).HasMaxLength(${Length}); // 2611"
		],
		"description": "Snippet to generate a String Primary Key with HasAnnotation Field"
	},
	"PKStringFluent": {
		"prefix": "Gen4-PrimaryKey-StringFluent-InConfiguration",
		"body": [
			"builder.HasKey(x => x.${PrimaryKey}); // 2611",
			"builder.Property(x => x.${PrimaryKey}).HasMaxLength(${Length});"
		],
		"description": "Snnipet to generate a Fluent String Primary Key Field"
	},
	"BuilderProgram": {
		"prefix": "Gen4-Builder-AddDbContext-InProgram",
		"body": [
			"",
			"builder.Services.AddDbContext<${Context}>(optionsBuilder => // 2611",
			"{",
			"\tstring connectionString = builder.Configuration.GetConnectionString(\"MySqlConex\");",
			"\toptionsBuilder.UseMySql(connectionString, ServerVersion.AutoDetect(connectionString));",
			"});",
			""
		]
	},
	"ModelBuilder": {
		"prefix": "Gen4-ModelBuilder-InContext",
		"body": [
			"protected override void OnModelCreating(ModelBuilder modelBuilder) // 2611",
			"{",
			"\tbase.OnModelCreating(modelBuilder);",
			"\tmodelBuilder.ApplyConfigurationsFromAssembly(Assembly.GetExecutingAssembly());",
			"}",
		]
	},
	"DevelopmentJson": {
		"prefix": "Gen4-ConectionStrings-InDevelopmentJson",
		"body": [
			",",
			"\"ConnectionStrings\": {",
			"\"ConexSqlServer\": \"Data Source=localhost\\\\\\sqlexpress;Initial Catalog=dB;Integrate Security=True\",",
			"\t\"MySqlConex\": \"server=localhost;user=root;password=${SqlPassword};database=${DataBase};\"",
			"}"
		]
	},
	"NoDevelopmentJson": {
		"prefix": "Gen4-JWTConfiguration-InNoDevelopmentJson",
		"body": [
			",",
			"\"ConnectionStrings\": {",
			"\"ConexSqlServer\": \"Data Source=localhost\\\\\\sqlexpress;Initial Catalog=dB;Integrate Security=True\",",
			"\t\"MySqlConex\": \"server=localhost;user=root;password=${SqlPassword};database=${DataBase};\"",
			"},",
			"\"JWT\": {",
			"\t\"Key\": \"${Token}\",",
			"\t\"Issuer\": \"ServidorDeApi\",",
			"\t\"Audience\": \"AppExternas\",",
			"\t\"DurationInMinutes\": 1",
			"  }"
		],
		"description": "Configuración JWT en archivo JSON"
	},
	"DbSetContext": {
		"prefix": "Gen4-DbSet-InContext",
		"body": [
			"public DbSet<${Entity}> ${Entities} { get; set; } // 2611"
		]
	},
	"ConstructorContext": {
		"prefix": "Gen4-Constructor-InContext",
		"body": [
			"public ${Context}(DbContextOptions<${Context}> options) : base(options) // 2611",
			"{",
			"}"
		]
	},
	"PrivateInterface": {
		"prefix": "Gen4-PrivateInterface-InUnitOfWork",
		"body": [
			"private I${Entity} _${Entities}; // 2611"
		]
	},
	"ConstructorUnitOfWork": {
		"prefix": "Gen4-Constructor-InUnitOfWork",
		"body": [
			"public UnitOfWork(${Context} context) // 2611",
			"{",
			"_context = context;",
			"}"
		]
	},
	"PublicInterface": {
		"prefix": "Gen4-PublicInterface-InUnitOfWork",
		"body": [
			"public ${IEntity} ${Entities} // 2611",
            "{",
            "\tget",
            "\t{",
            "\t\tif (_${Entities} == null)",
            "\t\t{",
            "\t\t\t_${Entities} = new ${EntityRepository}(_context); // Remember putting the base in the repository of this entity",
            "\t\t}",
            "\t\treturn _${Entities};",
            "\t}",
            "}"
		]
	},
	"SaveAsync": {
		"prefix": "Gen4-Task-SaveAsync-InUnitOfWork",
		"body": [
			"public Task<int> SaveAsync() // 2611",
			"{",
			"\treturn _context.SaveChangesAsync();",
			"}"
		],
		"description": "Snippet fot deleting the IUnitOfWork Problem"
	},
	"PublicIUnitOfWork": {
		"prefix": "Gen4-PublicInterface-InIUnitOfWork",
		"body": [
			"public I${Entity} ${Entities} { get; } // 2611"
		]
	},
	"Task": {
		"prefix": "Gen4-Task-SaveAsync-InIUnitOfWork",
		"body": [
			"Task<int> SaveAsync(); // 2611"
		]
	},
	"HttpGetIEnumerable": {
		"prefix": "Gen4-HttpGetIEnumerable-InController",
		"body": [
			"[HttpGet] // 2611",
			"[ProducesResponseType(StatusCodes.Status200OK)]",
			"[ProducesResponseType(StatusCodes.Status400BadRequest)]",
			"public async Task<ActionResult<IEnumerable<${Entity}Dto>>> Get()",
			"{",
			"\tvar results = await _unitOfWork.${Entities}.GetAllAsync();",
			"\treturn _mapper.Map<List<${Entity}Dto>>(results);",
			"}"
		]
	},
	"HttpGetObjectById": {
		"prefix": "Gen4-HttpGetObjectById-InController",
		"body": [
			"[HttpGet(\"{id}\")] // 2611",
            "[ProducesResponseType(StatusCodes.Status200OK)]",
            "[ProducesResponseType(StatusCodes.Status400BadRequest)]",
            "[ProducesResponseType(StatusCodes.Status404NotFound)]",
            "public async Task<ActionResult<${Entity}Dto>> Get(int id)",
            "{",
            "\tvar result = await _unitOfWork.${Entities}.GetByIdAsync(id);",
            "\tif (result == null)",
            "\t{",
            "\t\treturn NotFound();",
            "\t}",
            "\treturn _mapper.Map<${Entity}Dto>(result);",
            "}"
		]
	},
	"HttpPost": {
		"prefix": "Gen4-HttpPost-InController",
		"body": [
			"[HttpPost] // 2611",
			"[ProducesResponseType(StatusCodes.Status201Created)]",
			"[ProducesResponseType(StatusCodes.Status400BadRequest)]",
			"public async Task<ActionResult<${Entity}Dto>> Post(${Entity}Dto resultDto)",
			"{",
			"\tvar result = _mapper.Map<${Entity}>(resultDto);",
			"\t_unitOfWork.${Entities}.Add(result);",
			"\tawait _unitOfWork.SaveAsync();",
			"\tif (result == null)",
			"\t{",
			"\t\treturn BadRequest();",
			"\t}",
			"\tresultDto.Id = result.Id;",
			"\treturn CreatedAtAction(nameof(Post), new { id = resultDto.Id }, resultDto);",
			"}"
		],
		"description": "Crear un método de API POST"
	},
	"HttpDelete": {
		"prefix": "Gen4-HttpDelete-InController",
		"body": [
			"[HttpDelete(\"{id}\")] // 2611",
			"[ProducesResponseType(StatusCodes.Status204NoContent)]",
			"[ProducesResponseType(StatusCodes.Status404NotFound)]",
			"public async Task<IActionResult> Delete(int id)",
			"{",
			"\tvar result = await _unitOfWork.${Entities}.GetByIdAsync(id);",
			"\tif (result == null)",
			"\t{",
			"\t\treturn NotFound();",
			"\t}",
			"\t_unitOfWork.${Entities}.Remove(result);",
			"\tawait _unitOfWork.SaveAsync();",
			"\treturn NoContent();",
			"}"
		],
		"description": "Eliminar un registro usando el método DELETE"
	},
	"ConfigureCorsPolicy": {
		"prefix": "Gen4-ConfigureCors-InApplication",
		"body": [
			"public static void ConfigureCors(this IServiceCollection services) => services.AddCors(options => // 2611",
			"{",
			"\toptions.AddPolicy(\"CorsPolicy\", builder =>",
			"\t{",
			"\t\tbuilder.AllowAnyOrigin() // WithOrigins(\"https://domain.com\")",
			"\t\t.AllowAnyMethod() // WithMethods(\"GET\", \"POST\")",
			"\t\t.AllowAnyHeader(); // WithHeaders(\"accept\", \"content-type\")",
			"\t});",
			"}); // Remember to put 'static' on the class and to add builder.Services.ConfigureCors(); and app.UseCors(\"CorsPolicy\"); to Program.cs",
		],
		"description": "Configurar una política de CORS en ConfigureServices y Agregar servicios de aplicación al contenedor de dependencias"
	},
	"AddressProperties": {
		"prefix": "Gen4-AddressProperties-InEntity",
		"body": [
			"public string TipoVia { get; set; } // 2611",
			"public int NumeroPrincipal { get; set; }",
			"public string LetraPrincipal { get; set; }",
			"public string Bis { get; set; }",
			"public string LetraSecundaria { get; set; }",
			"public string CardinalPrimario { get; set; }",
			"public int NumeroSecundario { get; set; }",
			"public string LetraTerciaria { get; set; }",
			"public int NumeroTerciario { get; set; }",
			"public string CardinalSecundario { get; set; }",
			"public string Complemento { get; set; }",
			"public string CodigoPostal { get; set; }"
		],
		"description": "Propiedades para una clase de dirección"
	},
	"MappingProfilesConstructor": {
		"prefix": "Gen4-Constructor-InMappingProfiles",
		"body": [
			"public MappingProfiles() // Remember adding : Profile in the class",
			"{ // 2611",
			"\tCreateMap<${Entity}, ${Entity}Dto>().ReverseMap();",
			"}"
		],
		"description": "Constructor for AutoMapper MappingProfiles"
	},
	"ConfigureRateLimiting": {
		"prefix": "Gen4-ConfigureRateLimiting-InApplication",
		"body": [
			"public static void ConfigureRateLimiting(this IServiceCollection services) // 2611",
			"{",
			"\tservices.AddMemoryCache();",
			"\tservices.AddSingleton<IRateLimitConfiguration, RateLimitConfiguration>();",
			"\tservices.AddInMemoryRateLimiting();",
			"\tservices.Configure<IpRateLimitOptions>(options =>",
			"\t{",
			"\t\toptions.EnableEndpointRateLimiting = true;",
			"\t\toptions.StackBlockedRequests = false;",
			"\t\toptions.HttpStatusCode = 429;",
			"\t\toptions.RealIpHeader = \"X-Real-IP\";",
			"\t\toptions.GeneralRules = new List<RateLimitRule>",
			"\t\t{",
			"\t\t\tnew RateLimitRule",
			"\t\t\t{",
			"\t\t\t\tEndpoint = \"${Endpoint}\",  // Si quiere usar todos ponga *",
			"\t\t\t\tPeriod = \"${NumberSecs}s\", // Periodo de tiempo para hacer peticiones",
			"\t\t\t\tLimit = ${Petitions}         // Numero de peticiones durante el periodo de tiempo",
			"\t\t\t}",
			"\t\t};",
			"\t});",
			"} // Remember adding builder.Services.ConfigureRateLimiting(); and builder.Services.AddAutoMapper(Assembly.GetEntryAssembly()); and app.UseIpRateLimiting(); to Program.cs"
		],
		"description": "Configure Rate Limiting using ASP.NET Core middleware"
	},
	"AddApplicationServices": {
		"prefix": "Gen4-AddApplicationServices-InApplication",
		"body": [
			"public static void AddApplicationServices(this IServiceCollection services) // 2611",
			"{",
			"\tservices.AddScoped<IUnitOfWork, UnitOfWork>();",
			"} // Remember to add builder.Services.AddApplicationServices(); to Program.cs"
		],
		"description": "Agregar servicios de aplicación al contenedor de dependencias"
	},
	"GetAllAsyncMethod": {
		"prefix": "Gen4-GetAllAsyncMethod-InRepository",
		"body": [
			"public override async Task<IEnumerable<${Entity}>> GetAllAsync() // 2611",
			"{",
			"\treturn await _context.${Entities}",
			"\t\t\t\t.Include(c => c.${includedEntity})",
			"\t\t\t\t.ToListAsync();",
			"}"
		],
		"description": "Método para obtener todos los registros de la entidad con inclusión"
	},
	"GetAllAsyncMethodForRegistros": {
		"prefix": "Gen4-GetAllAsyncMethod-ForRegistros-InRepository",
		"body": [
			"public override async Task<(int totalRegistros, IEnumerable<${Entity}> registros)> GetAllAsync( // 2611",
			"\tint pageIndex,",
			"\tint pageSize,",
			"\tstring search",
			")",
			"{",
			"\tvar query = _context.${Entities} as IQueryable<${Entity}>;",
			"",
			"\tif (!string.IsNullOrEmpty(search))",
			"\t{",
			"\t\tquery = query.Where(p => p.${varQuery}.ToLower().Contains(search)); // If necesary add .ToString() after varQuery",
			"\t}",
			"\tquery = query.OrderBy(p => p.Id);",
			"",
			"\tvar totalRegistros = await query.CountAsync();",
			"\tvar registros = await query",
			"\t\t\t\t\t.Include(p => p.${includedEntity})",
			"\t\t\t\t\t.Skip((pageIndex - 1) * pageSize)",
			"\t\t\t\t\t.Take(pageSize)",
			"\t\t\t\t\t.ToListAsync();",
			"\treturn (totalRegistros, registros);",
			"}"
		],
		"description": "Método para obtener registros paginados con búsqueda en la entidad"
	},
	"Pager Class": {
		"prefix": "Gen4-PagerClass-InPager",
		"body": [
			"using System; // 2611",
			"using System.Collections.Generic;",
			"using System.Linq;",
			"using System.Threading.Tasks;",
			"",
			"namespace API.Helpers;",
			"",
			"public class Pager<T> where T : class",
			"\t{",
			"\tpublic string Search { get; set; }",
			"\tpublic int PageIndex { get; set; }",
			"\tpublic int PageSize { get; set; }",
			"\tpublic int Total { get; set; }",
			"\tpublic List<T> Registers { get; private set; }",
			"",
			"\tpublic Pager()",
			"\t{",
			"\t}",
			"",
			"\tpublic Pager(List<T> registers, int total, int pageIndex, int pageSize, string search)",
			"\t{",
			"\t\tRegisters = registers;",
			"\t\tTotal = total;",
			"\t\tPageIndex = pageIndex;",
			"\t\tPageSize = pageSize;",
			"\t\tSearch = search;",
			"\t}",
			"",
			"\tpublic int TotalPages",
			"\t{",
			"\t\tget { return (int)Math.Ceiling(Total / (double)PageSize); }",
			"\t\tset { this.TotalPages = value; }",
			"\t}",
			"",
			"\tpublic bool HasPreviousPage",
			"\t{",
			"\t\tget { return (PageIndex > 1); }",
			"\t\tset { this.HasPreviousPage = value; }",
			"\t}",
			"",
			"\tpublic bool HasNextPage",
			"\t{",
			"\t\tget { return (PageIndex < TotalPages); }",
			"\t\tset { this.HasNextPage = value; }",
			"\t}",
			"}"
		],
		"description": "Clase Pager genérica para la paginación de registros"
	},
	"Params Class": {
		"prefix": "Gen4-ParamsClass-InParams",
		"body": [
			"using System; // 2611",
			"using System.Collections.Generic;",
			"using System.Linq;",
			"using System.Threading.Tasks;",
			"",
			"namespace API.Helpers;",
			"",
			"public class Params",
			"{",
			"\tprivate int _pageSize = 5;",
			"\tprivate const int MaxPageSize = 50;",
			"\tprivate int _pageIndex = 1;",
			"\tprivate string _search;",
			"",
			"\tpublic int PageSize",
			"\t{",
			"\t\tget => _pageSize;",
			"\t\tset => _pageSize = (value > MaxPageSize) ? MaxPageSize : value;",
			"\t}",
			"",
			"\tpublic int PageIndex",
			"\t{",
			"\t\tget => _pageIndex;",
			"\t\tset => _pageIndex = (value <= 0) ? 1 : value;",
			"\t}",
			"",
			"\tpublic string Search",
			"\t{",
			"\t\tget => _search;",
			"\t\tset => _search = (!String.IsNullOrEmpty(value)) ? value.ToLower() : \"\";",
			"\t}",
			"}"
		],
		"description": "Clase Params para definir parámetros de paginación y búsqueda"
	},
	"Set Audit Dates": {
		"prefix": "Gen4-DateConditional-InController",
		"body": [
			"if (resultDto.${Date} == DateOnly.MinValue) // 2611",
			"{",
			"\tresultDto.${Date} = DateOnly.FromDateTime(DateTime.Now);",
			"\tresult.${Date} = DateOnly.FromDateTime(DateTime.Now);",
			"}"
		],
		"description": "Establecer fechas de auditoría si son DateOnly.MinValue"
	},
	"Set Audit Times": {
		"prefix": "Gen4-TimeConditional-InController",
		"body": [
			"if (resultDto.${Time} == TimeOnly.MinValue) // 2611",
			"{",
			"\tresultDto.${Time} = TimeOnly.FromDateTime(DateTime.Now);",
			"\tresult.${Time} = TimeOnly.FromDateTime(DateTime.Now);",
			"}"
		],
		"description": "Establecer horas de auditoría si son TimeOnly.MinValue"
	},
	"Add JWT Authentication": {
		"prefix": "Gen4-AddJwt-InApplication",
		"body": [
			"public static void AddJwt(this IServiceCollection services, IConfiguration configuration) // 2611",
			"{",
			"\t// Configuration from AppSettings",
			"\tservices.Configure<JWT>(configuration.GetSection(\"JWT\"));",
			"",
			"\t// Adding Authentication - JWT",
			"\tservices.AddAuthentication(options =>",
			"\t{",
			"\t\toptions.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;",
			"\t\toptions.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;",
			"\t})",
			"\t.AddJwtBearer(o =>",
			"\t{",
			"\t\to.RequireHttpsMetadata = false;",
			"\t\to.SaveToken = false;",
			"\t\to.TokenValidationParameters = new TokenValidationParameters",
			"\t\t{",
			"\t\t\tValidateIssuerSigningKey = true,",
			"\t\t\tValidateIssuer = true,",
			"\t\t\tValidateAudience = true,",
			"\t\t\tValidateLifetime = true,",
			"\t\t\tClockSkew = TimeSpan.Zero,",
			"\t\t\tValidIssuer = configuration[\"JWT:Issuer\"],",
			"\t\t\tValidAudience = configuration[\"JWT:Audience\"],",
			"\t\t\tIssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(configuration[\"JWT:Key\"]))",
			"\t\t};",
			"\t});",
			"}"
		],
		"description": "Configurar autenticación JWT en ASP.NET Core"
	},
	"JWT Configuration Class": {
		"prefix": "Gen4-JWT-InHelpers",
		"body": [
			"public string Key { get; set; } // 2611",
			"public string Issuer { get; set; }",
			"public string Audience { get; set; }",
			"public double DurationInMinutes { get; set; }"
		],
		"description": "Clase de configuración para JWT"
	},
	"Put Method": {
		"prefix": "Gen4-HttpPut-InController-Good",
		"body": [
			"[HttpPut(\"{id}\")] // 2611",
			"[ProducesResponseType(StatusCodes.Status200OK)]",
			"[ProducesResponseType(StatusCodes.Status400BadRequest)]",
			"[ProducesResponseType(StatusCodes.Status404NotFound)]",
			"public async Task<ActionResult<${Entity}Dto>> Put(int id, [FromBody] ${Entity}Dto resultDto)",
			"{",
			"\tvar exists = await _unitOfWork.${Entities}.GetByIdAsync(id);",
			"\tif (exists == null)",
			"\t{",
			"\t\treturn NotFound();",
			"\t}",
			"\tif (resultDto.Id == 0)",
			"\t{",
			"\t\tresultDto.Id = id;",
			"\t}",
			"\tif (resultDto.Id != id)",
			"\t{",
			"\t\treturn BadRequest();",
			"\t}",
			"\t// Update the properties of the existing entity with values from resultDto",
			"\t_mapper.Map(resultDto, exists);",
			"\tif (resultDto.FechaCreacion == DateOnly.MinValue)",
			"\t{",
			"\t\texists.FechaCreacion = DateOnly.FromDateTime(DateTime.Now);",
			"\t}",
			"\t// The context is already tracking result, so no need to attach it",
			"\tawait _unitOfWork.SaveAsync();",
			"\t// Return the updated entity",
			"\treturn _mapper.Map<${Entity}Dto>(exists);",
			"}"
		],
		"description": "Método PUT para actualizar una entidad"
	},
	"Composite Key Definition": {
		"prefix": "Gen4-CompositePrimaryKey-InConfiguration",
		"body": [
			"builder.HasKey(e => new { e.${ForeignKey1}, e.${ForeignKey2} }); // 2611"
		],
		"description": "Definir una clave compuesta en Entity Framework Core"
	},
	"User Service Interface": {
		"prefix": "Gen4-IUserService-InServices",
		"body": [
			"using System; // 2611",
			"using System.Collections.Generic;",
			"using System.Linq;",
			"using System.Threading.Tasks;",
			"using API.Dtos;",
			"",
			"namespace API.Services",
			"{",
			"\tpublic interface IUserService",
			"\t{",
			"\t\tTask<string> RegisterAsync(RegisterDto model);",
			"\t\tTask<DataUserDto> GetTokenAsync(LoginDto model);",
			"\t\tTask<string> AddRolAsync(AddRolDto model);",
			"\t\tTask<DataUserDto> RefreshTokenAsync(string RefreshToken);",
			"\t}",
			"}"
		],
		"description": "Interfaz de servicio de usuario"
	},
	"UserService Class": {
		"prefix": "Gen4-UserService-InServices",
		"body": [
			"using System.IdentityModel.Tokens.Jwt; // 2611",
			"using Domain.Entities;",
			"using Domain.Interfaces;",
			"using Microsoft.AspNetCore.Identity;",
			"using Microsoft.Extensions.Options;",
			"using API.Dtos;",
			"using API.Helpers;",
			"using System.Security.Claims;",
			"using Microsoft.IdentityModel.Tokens;",
			"using System.Text;",
			"using System.Security.Cryptography;",
			"",
			"namespace API.Services;",
			"",
			"public class UserService : IUserService",
			"{",
			"\tprivate readonly JWT _jwt;",
			"\tprivate readonly IUnitOfWork _unitOfWork;",
			"\tprivate readonly IPasswordHasher<User> _passwordHasher;",
			"\tpublic UserService(IUnitOfWork unitOfWork, IOptions<JWT> jwt, IPasswordHasher<User> passwordHasher)",
			"\t{",
			"\t\t_jwt = jwt.Value;",
			"\t\t_unitOfWork = unitOfWork;",
			"\t\t_passwordHasher = passwordHasher;",
			"\t}",
			"\tpublic async Task<string> RegisterAsync(RegisterDto registerDto)",
			"\t{",
			"\t\tvar user = new User",
			"\t\t{",
			"\t\t\tEmail = registerDto.Email,",
			"\t\t\tUsername = registerDto.Username",
			"\t\t};",
			"\t\tuser.Password = _passwordHasher.HashPassword(user, registerDto.Password); //Encrypt password",
			"\t\tvar existingUser = _unitOfWork.Users",
			"\t\t\t\t\t\t\t.Find(u => u.Username.ToLower() == registerDto.Username.ToLower())",
			"\t\t\t\t\t\t\t.FirstOrDefault();",
			"\t\tif (existingUser == null)",
			"\t\t{",
			"\t\t\tvar rolDefault = _unitOfWork.Rols",
			"\t\t\t\t\t\t\t.Find(u => u.Name == Authorization.rol_default.ToString())",
			"\t\t\t\t\t\t\t.First();",
			"\t\t\ttry",
			"\t\t\t{",
			"\t\t\t\tuser.Rols.Add(rolDefault);",
			"\t\t\t\t_unitOfWork.Users.Add(user);",
			"\t\t\t\tawait _unitOfWork.SaveAsync();",
			"\t\t\t\treturn $\"User  {registerDto.Username} has been registered successfully\";",
			"\t\t\t}",
			"\t\t\tcatch (Exception ex)",
			"\t\t\t{",
			"\t\t\t\t\tvar message = ex.Message;",
			"\t\t\t\t\treturn $\"Error: {message}\";",
			"\t\t\t}",
			"\t\t}",
			"\t\telse",
			"\t\t{",
			"\t\t\treturn $\"User {registerDto.Username} already registered.\";",
			"\t\t}",
			"\t}",
			"",
			"\tpublic async Task<DataUserDto> GetTokenAsync(LoginDto model)",
			"\t{",
			"\t\tDataUserDto dataUserDto = new DataUserDto();",
			"\t\tvar user = await _unitOfWork.Users.GetByUsernameAsync(model.UserName);",
			"\t\tif (user == null)",
			"\t\t{",
			"\t\t\tdataUserDto.IsAuthenticated = false;",
			"\t\t\tdataUserDto.Message = $\"User does not exist with Username {model.UserName}.\";",
			"\t\t\treturn dataUserDto;",
			"\t\t}",
			"\t\tvar result = _passwordHasher.VerifyHashedPassword(user, user.Password, model.Password);",
			"\t\tif (result == PasswordVerificationResult.Success)",
			"\t\t{",
			"\t\t\tdataUserDto.IsAuthenticated = true;",
			"\t\t\tJwtSecurityToken jwtSecurityToken = CreateJwtToken(user);",
			"\t\t\tdataUserDto.Token = new JwtSecurityTokenHandler().WriteToken(jwtSecurityToken);",
			"\t\t\tdataUserDto.Email = user.Email;",
			"\t\t\tdataUserDto.UserName = user.Username;",
			"\t\t\tdataUserDto.Rols = user.Rols",
			"\t\t\t\t\t\t\t\t.Select(u => u.Name)",
			"\t\t\t\t\t\t\t\t.ToList();",
			"\t\t\tif (user.RefreshTokens.Any(a => a.IsActive))",
			"\t\t\t{",
			"\t\t\t\tvar activeRefreshToken = user.RefreshTokens.Where(a => a.IsActive == true).FirstOrDefault();",
			"\t\t\t\tdataUserDto.RefreshToken = activeRefreshToken.Token;",
			"\t\t\t\tdataUserDto.RefreshTokenExpiration = activeRefreshToken.Expires;",
			"\t\t\t}",
			"\t\t\telse",
			"\t\t\t{",
			"\t\t\t\tvar refreshToken = CreateRefreshToken();",
			"\t\t\t\tdataUserDto.RefreshToken = refreshToken.Token;",
			"\t\t\t\tdataUserDto.RefreshTokenExpiration = refreshToken.Expires;",
			"\t\t\t\tuser.RefreshTokens.Add(refreshToken);",
			"\t\t\t\t_unitOfWork.Users.Update(user);",
			"\t\t\t\tawait _unitOfWork.SaveAsync();",
			"\t\t\t}",
			"\t\t\treturn dataUserDto;",
			"\t\t}",
			"\t\tdataUserDto.IsAuthenticated = false;",
			"\t\tdataUserDto.Message = $\"Credenciales incorrectas para el usuario {user.Username}.\";",
			"\t\treturn dataUserDto;",
			"\t}",
			"",
			"\tpublic async Task<string> AddRolAsync(AddRolDto model)",
			"\t{",
			"\t\tvar user = await _unitOfWork.Users.GetByUsernameAsync(model.UserName);",
			"\t\tif (user == null)",
			"\t\t{",
			"\t\t\treturn $\"User {model.UserName} does not exists.\";",
			"\t\t}",
			"\t\tvar result = _passwordHasher.VerifyHashedPassword(user, user.Password, model.Password);",
			"\t\tif (result == PasswordVerificationResult.Success)",
			"\t\t{",
			"\t\t\tvar rolExists = _unitOfWork.Rols",
			"\t\t\t\t\t\t\t.Find(u => u.Name.ToLower() == model.Rol.ToLower())",
			"\t\t\t\t\t\t\t.FirstOrDefault();",
			"\t\t\tif (rolExists != null)",
			"\t\t\t{",
			"\t\t\t\tvar userHasRol = user.Rols.Any(u => u.Id == rolExists.Id);",
			"\t\t\t\tif (userHasRol == false)",
			"\t\t\t\t{",
			"\t\t\t\t\tuser.Rols.Add(rolExists);",
			"\t\t\t\t\t_unitOfWork.Users.Update(user);",
			"\t\t\t\t\tawait _unitOfWork.SaveAsync();",
			"\t\t\t\t}",
			"\t\t\t\treturn $\"Rol {model.Rol} added to user {model.UserName} successfully.\";",
			"\t\t\t}",
			"\t\t\treturn $\"Rol {model.Rol} was not found.\";",
			"\t\t}",
			"\t\treturn $\"Invalid Credentials\";",
			"\t}",
			"",
			"\tpublic async Task<DataUserDto> RefreshTokenAsync(string refreshToken)",
			"\t{",
			"\t\tvar dataUserDto = new DataUserDto();",
			"\t\tvar usuario = await _unitOfWork.Users.GetByRefreshTokenAsync(refreshToken);",
			"\t\tif (usuario == null)",
			"\t\t{",
			"\t\t\tdataUserDto.IsAuthenticated = false;",
			"\t\t\tdataUserDto.Message = $\"Token is not assigned to any user.\";",
			"\t\t\treturn dataUserDto;",
			"\t\t}",
			"\t\tvar refreshTokenBd = usuario.RefreshTokens.Single(x => x.Token == refreshToken);",
			"\t\tif (!refreshTokenBd.IsActive)",
			"\t\t{",
			"\t\t\tdataUserDto.IsAuthenticated = false;",
			"\t\t\tdataUserDto.Message = $\"Token is not active.\";",
			"\t\t\treturn dataUserDto;",
			"\t\t}",
			"\t\t//Revoque the current refresh token and",
			"\t\trefreshTokenBd.Revoked = DateTime.UtcNow;",
			"\t\t//generate a new refresh token and save it in the database",
			"\t\tvar newRefreshToken = CreateRefreshToken();",
			"\t\tusuario.RefreshTokens.Add(newRefreshToken);",
			"\t\t_unitOfWork.Users.Update(usuario);",
			"\t\tawait _unitOfWork.SaveAsync();",
			"\t\t//Generate a new Json Web Token",
			"\t\tdataUserDto.IsAuthenticated = true;",
			"\t\tJwtSecurityToken jwtSecurityToken = CreateJwtToken(usuario);",
			"\t\tdataUserDto.Token = new JwtSecurityTokenHandler().WriteToken(jwtSecurityToken);",
			"\t\tdataUserDto.Email = usuario.Email;",
			"\t\tdataUserDto.UserName = usuario.Username;",
			"\t\tdataUserDto.Rols = usuario.Rols",
			"\t\t\t\t\t\t\t.Select(u => u.Name)",
			"\t\t\t\t\t\t\t.ToList();",
			"\t\tdataUserDto.RefreshToken = newRefreshToken.Token;",
			"\t\tdataUserDto.RefreshTokenExpiration = newRefreshToken.Expires;",
			"\t\treturn dataUserDto;",
			"\t}",
			"",
			"\tprivate RefreshToken CreateRefreshToken()",
			"\t{",
			"\t\tvar randomNumber = new byte[32];",
			"\t\tusing (var generator = RandomNumberGenerator.Create())",
			"\t\t{",
			"\t\t\tgenerator.GetBytes(randomNumber);",
			"\t\t\treturn new RefreshToken",
			"\t\t\t{",
			"\t\t\t\tToken = Convert.ToBase64String(randomNumber),",
			"\t\t\t\tExpires = DateTime.UtcNow.AddDays(10),",
			"\t\t\t\tCreated = DateTime.UtcNow",
			"\t\t\t};",
			"\t\t}",
			"\t}",
			"",
			"\tprivate JwtSecurityToken CreateJwtToken(User usuario)",
			"\t{",
			"\t\tvar rols = usuario.Rols;",
			"\t\tvar rolClaims = new List<Claim>();",
			"\t\tforeach (var rol in rols)",
			"\t\t{",
			"\t\t\trolClaims.Add(new Claim(\"rols\", rol.Name));",
			"\t\t}",
			"\t\tvar claims = new[]",
			"\t\t{",
			"\t\t\tnew Claim(JwtRegisteredClaimNames.Sub, usuario.Username),",
			"\t\t\tnew Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString()),",
			"\t\t\tnew Claim(JwtRegisteredClaimNames.Email, usuario.Email),",
			"\t\t\tnew Claim(\"uid\", usuario.Id.ToString())",
			"\t\t}",
			"\t\t.Union(rolClaims);",
			"\t\tvar symmetricSecurityKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_jwt.Key));",
			"\t\tvar signingCredentials = new SigningCredentials(symmetricSecurityKey, SecurityAlgorithms.HmacSha256);",
			"\t\tvar jwtSecurityToken = new JwtSecurityToken(",
			"\t\t\tissuer: _jwt.Issuer,",
			"\t\t\taudience: _jwt.Audience,",
			"\t\t\tclaims: claims,",
			"\t\t\texpires: DateTime.UtcNow.AddMinutes(_jwt.DurationInMinutes),",
			"\t\t\tsigningCredentials: signingCredentials);",
			"\t\treturn jwtSecurityToken;",
			"\t}",
			"}",
		],
		"description": "Clase de servicio de usuario"
	},
	"RefreshToken Class": {
		"prefix": "Gen4-RefreshToken-InEntities",
		"body": [
			"public string Token { get; set; } // 2611",
			"public DateTime Expires { get; set; }",
			"public bool IsExpired => DateTime.UtcNow >= Expires;",
			"public DateTime Created { get; set; }",
			"public DateTime? Revoked { get; set; }",
			"public bool IsActive => Revoked == null && !IsExpired;",
			"public int IdUserFk { get; set; }",
			"public User Users { get; set; }",
		],
		"description": "Clase RefreshToken con propiedades y métodos"
	},
	"UserRol Class": {
		"prefix": "Gen4-Rol-InEntities",
		"body": [
			"public string Name { get; set; } // 2611",
			"public ICollection<User> Users { get; set; } = new HashSet<User>();",
			"public ICollection<UserRol> UserRols { get; set; }",
		],
		"description": "Definición de una clase UserRol con propiedades Name, Users y UserRols"
	},
	"User Class": {
		"prefix": "Gen4-User-InEntities",
		"body": [
			"public string Username { get; set; } // 2611",
			"public string Email { get; set; }",
			"public string Password { get; set; }",
			"public ICollection<Rol> Rols { get; set; } = new HashSet<Rol>();",
			"public ICollection<RefreshToken> RefreshTokens { get; set; } = new HashSet<RefreshToken>();",
			"public ICollection<UserRol> UserRols { get; set; } = new HashSet<UserRol>();",
		],
		"description": "Definición de una clase User con propiedades Username, Email, Password, Rols, RefreshTokens y UserRols"
	},
	"UserRol Class Properties": {
		"prefix": "Gen4-UserRol-InEntities",
		"body": [
			"public int IdUserFk { get; set; } // 2611",
			"public User Users { get; set; }",
			"public int IdRolFk { get; set; }",
			"public Rol Rols { get; set; }"
		],
		"description": "Propiedades de una clase UserRol con IdUserFk, Users, IdRolFk y Rols"
	},
	"Get User by RefreshToken": {
		"prefix": "Gen-Methods-InUserRepository",
		"body": [
			"public async Task<User> GetByRefreshTokenAsync(string refreshToken) // 2611",
			"{",
			"\treturn await _context.Users",
			"\t\t\t\t.Include(u => u.Rols)",
			"\t\t\t\t.Include(u => u.RefreshTokens)",
			"\t\t\t\t.FirstOrDefaultAsync(u => u.RefreshTokens.Any(t => t.Token == refreshToken));",
			"}",
			"",
			"public async Task<User> GetByUsernameAsync(string username)",
			"{",
			"\treturn await _context.Users",
			"\t\t\t\t.Include(u => u.Rols)",
			"\t\t\t\t.Include(u => u.RefreshTokens)",
			"\t\t\t\t.FirstOrDefaultAsync(u => u.Username.ToLower() == username.ToLower());",
			"}"
		],
		"description": "Methods for users by their username."
	},
	"User Repository Methods": {
		"prefix": "Gen4-Methods-InIUser",
		"body": [
			"Task<User> GetByUsernameAsync(string username); // 2611",
			"Task<User> GetByRefreshTokenAsync(string refreshToken);"
		],
		"description": "Métodos de repositorio para obtener un usuario por nombre de usuario o por RefreshToken"
	},
	"Enum and Default Role": {
		"prefix": "Gen4-EnumAndDefaultRole-InAuthorization-Helpers",
		"body": [
			"public enum Roles // 2611",
			"{",
			"\tAdministrator,",
			"\tManager,",
			"\tEmployee,",
			"\tPerson",
			"}",
			"",
			"public const Roles rol_default = Roles.Person;"
		],
		"description": "Declaración de un enumerado y constante para roles"
	},
	"JWT Configuration": {
		"prefix": "Gen4-JwtConfiguration-InJWT-Helpers",
		"body": [
			"public string Key { get; set; } // 2611",
			"public string Issuer { get; set; }",
			"public string Audience { get; set; }",
			"public double DurationInMinutes { get; set; }",
		],
		"description": "Clase de configuración para JWT"
	},
	"Required Properties": {
		"prefix": "Gen4-AddRolDto-InDtos",
		"body": [
			"[Required] // 2611",
			"public string UserName { get; set; }",
			"[Required]",
			"public string Password { get; set; }",
			"[Required]",
			"public string Rol { get; set; }"
		],
		"description": "Clase con propiedades marcadas como [Required]"
	},
	"User Authentication Response": {
		"prefix": "Gen4-DataUserDto-InDtos",
		"body": [
			"public string Message { get; set; } // 2611",
			"public bool IsAuthenticated { get; set; }",
			"public string UserName { get; set; }",
			"public string Email { get; set; }",
			"public List<string> Rols { get; set; }",
			"public string Token { get; set; }",
			"[JsonIgnore] // This attribute restricts the property to be shown in the result",
			"public string RefreshToken { get; set; }",
			"public DateTime RefreshTokenExpiration { get; set; }"
		],
		"description": "Clase de respuesta de autenticación de usuario"
	},
	"User Authentication Request": {
		"prefix": "Gen4-LoginDto-InDtos",
		"body": [
			"[Required] // 2611",
			"public string UserName { get; set; }",
			"[Required]",
			"public string Password { get; set; }"
		],
		"description": "Modelo de solicitud de autenticación de usuario"
	},
	"User Registration Request": {
		"prefix": "Gen4-RegisterDto-InDtos",
		"body": [
			"[Required] // 2611",
			"public string Email { get; set; }",
			"[Required]",
			"public string Username { get; set; }",
			"[Required]",
			"public string Password { get; set; }"
		],
		"description": "Modelo de solicitud de registro de usuario"
	},
	"Configure Many-to-Many Relationship": {
		"prefix": "Gen-UserRolManyToMany-InConfiguration",
		"body": [
			"builder.HasMany(e => e.Rols).WithMany(c => c.Users).UsingEntity<UserRol>( // 2611",
			"\ty => y.HasOne(e => e.Rols).WithMany(e => e.UserRols).HasForeignKey(c => c.IdRolFk),",
			"\ty => y.HasOne(e => e.Users).WithMany(e => e.UserRols).HasForeignKey(c => c.IdUserFk),",
			"\ty => {",
			"\t\ty.ToTable(\"userrol\");",
			"\t\ty.HasKey(z => new { z.IdUserFk, z.IdRolFk });",
			"\t}",
			");"
		],
		"description": "Configure a Many-to-Many relationship in Entity Framework."
	},
	"ControllerUser": {
		"prefix": "Gen4-UserController-InControllers",
		"body": [
			"[HttpPost(\"register\")] // 2611",
			"public async Task<ActionResult> RegisterAsync(RegisterDto model)",
			"{",
			"\tvar result = await _userService.RegisterAsync(model);",
			"\treturn Ok(result);",
			"}",
			"[HttpPost(\"token\")]",
            "public async Task<ActionResult> GetTokenAsync(LoginDto model)",
            "{",
            "\tvar result = await _userService.GetTokenAsync(model);",
            "\tSetRefreshTokenInCookie(result.RefreshToken);",
            "\treturn Ok(result);",
            "}",
			"[HttpPost(\"addrol\")]",
            "public async Task<ActionResult> AddRolAsync(AddRolDto model)",
            "{",
            "\tvar result = await _userService.AddRolAsync(model);",
            "\treturn Ok(result);",
            "}",
			"[HttpPost(\"refresh-token\")]",
            "public async Task<ActionResult> RefreshToken()",
            "{",
            "\tvar refreshToken = Request.Cookies[\"refreshToken\"];",
            "\tvar result = await _userService.RefreshTokenAsync(refreshToken);",
            "\tif (!string.IsNullOrEmpty(result.RefreshToken))",
            "\t{",
            "\t\tSetRefreshTokenInCookie(result.RefreshToken);",
            "\t}",
            "\treturn Ok(result);",
            "}",
			"private void SetRefreshTokenInCookie(string refreshToken)",
            "{",
            "\tvar cookieOptions = new CookieOptions",
            "\t{",
            "\t\tHttpOnly = true,",
            "\t\tExpires = DateTime.UtcNow.AddDays(2),",
            "\t};",
            "\tResponse.Cookies.Append(\"refreshToken\", refreshToken, cookieOptions);",
            "}"
		],
		"description": "Action method for user registration."
	},
	"Entity Property and Unique Index Configuration": {
		"prefix": "Gen4-IsUnique-InConfiguration",
		"body": [
			"builder.Property(x => x.${Key}).IsRequired().HasMaxLength(${Length});",
			"builder.HasIndex(x => x.${Key}).IsUnique();"
		],
		"description": "Entity Framework property configuration with a unique index."
	},
	"Database Migration with Error Handling": {
		"prefix": "Gen4-DbFirstMigration-InProgram",
		"body": [
			"using (var scope = app.Services.CreateScope())",
			"{",
			"\tvar services = scope.ServiceProvider;",
			"\tvar loggerFactory = services.GetRequiredService<ILoggerFactory>();",
			"\ttry",
			"\t{",
			"\t\tvar context = services.GetRequiredService<${Context}>();",
			"\t\tawait context.Database.MigrateAsync();",
			"\t}",
			"\tcatch (Exception ex)",
			"\t{",
			"\t\tvar _logger = loggerFactory.CreateLogger<Program>();",
			"\t\t_logger.LogError(ex, \"There was an error while migrating\");",
			"\t}",
			"}"
		],
		"description": "Database migration with error handling using Entity Framework Core."
	},
	"Database": {
		"prefix": "Gen4-ScaffoldCode-ForDbFirst",
		"body": [
			"dotnet ef dbcontext scaffold \"server=localhost;user=root;password=${Password};database=${DbName}\" Pomelo.EntityFrameworkCore.MySql -s API -p Persistence --context ${Context} --context-dir Data --output-dir Entities"
		]
	}

}